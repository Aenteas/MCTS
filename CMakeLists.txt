# This file has been generated by scripts/generate_cmake.py

cmake_minimum_required (VERSION 3.22.0)

project(mcts_swig VERSION 1.2.3)
# we need it so we can output generated files under ROOT_BINARY_DIR/python (python modules) and ROOT_BINARY_DIR/lib (C++ libraries)
set(ROOT_BINARY_DIR ${PROJECT_BINARY_DIR})
set(MAIN_PROJECT ${PROJECT_NAME})

# set C++ compiler version

set(CMAKE_CXX_STANDARD 17 CACHE STRING "The C++ standard to use")
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Find the QtWidgets library
find_package(Qt5 REQUIRED COMPONENTS Gui)
find_package(Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt5 REQUIRED COMPONENTS Core)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
# external projects could see target libraries by just calling find_package in CMake script instead of calling 
# export LD_LIBRARY_PATH=<project_root>/cmake/liba/_install/lib/ which is not the best practice
set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)

# build options
set(FORCE_BUILD "" CACHE STRING "List of relative paths to build")
set(FORCE_NO_BUILD "" CACHE STRING "List of relative paths to not build")

# build options will be processed by python script to check logical/spelling errors
# it will output option variables
set(OPTION_PY_IN ${CMAKE_CURRENT_SOURCE_DIR}/scripts/create_cmake_options.py.in)
set(OPTION_PY_OUT ${CMAKE_CURRENT_BINARY_DIR}/scripts/create_cmake_options.py)

# python fsting uses the curly brackets so we need to aply @ONLY to insert CMake variables
configure_file(${OPTION_PY_IN} ${OPTION_PY_OUT} @ONLY)

# call python script
execute_process(
COMMAND sudo python3 ${OPTION_PY_OUT}
OUTPUT_STRIP_TRAILING_WHITESPACE
OUTPUT_VARIABLE OPTIONS
RESULT_VARIABLE EXIT_STATUS)

# if script runs without errors
if(EXIT_STATUS EQUAL "0")
  foreach(OPTION_STR ${OPTIONS})
    # parsing python output to get build options
    string(REPLACE ":" ";" BUILD_OPTION ${OPTION_STR})
    # format is <option name>:<description>:<ON/OFF>
    list (GET BUILD_OPTION 0 OPTION_NAME)
    list (GET BUILD_OPTION 1 OPTION_DESC)
    list (GET BUILD_OPTION 2 OPTION_FLAG)
    option(USE_${OPTION_NAME} "${OPTION_DESC}" ${OPTION_FLAG})
    set(USE_${OPTION_NAME} ${OPTION_FLAG} CACHE INTERNAL "")

    option(USE_${MAIN_PROJECT}_${OPTION_NAME} "${OPTION_DESC}" ${OPTION_FLAG})
  endforeach()
  # saving build options to header files 
  set(BUILD_CONFIG_IN ${CMAKE_CURRENT_BINARY_DIR}/include/build_info.h.in)
  set(BUILD_CONFIG_OUT ${CMAKE_CURRENT_BINARY_DIR}/include/build_info.h)
  configure_file(${BUILD_CONFIG_IN} ${BUILD_CONFIG_OUT})

  set(INSTALL_CONFIG_IN ${CMAKE_CURRENT_BINARY_DIR}/include/build_info_install.h.in)
  set(INSTALL_CONFIG_OUT ${CMAKE_CURRENT_BINARY_DIR}/include/build_info_install.h)
  configure_file(${INSTALL_CONFIG_IN} ${INSTALL_CONFIG_OUT})

  # declare lists for targets and include dirs so subdirectories can update them
  # INTERNAL creates a make-shift global variable that can be updated from subdirectories
  set(TARGETS "" CACHE INTERNAL "")
  set(INCLUDE_DIRS "" CACHE INTERNAL "")
  
  if(USE_ENGINE)
    add_subdirectory(engine)
  endif()
  if(USE_UI)
    add_subdirectory(ui)
  endif()

  # includes for install/exporting
  include(GenerateExportHeader)
  include(GNUInstallDirs)
  include(CMakePackageConfigHelpers)

  # Configuration

  set(CONFIG_INSTALL_DIR "${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}")

  set(VERSION_CONFIG "${CMAKE_CURRENT_BINARY_DIR}/cmake/${PROJECT_NAME}ConfigVersion.cmake")
  set(PROJECT_CONFIG "${CMAKE_CURRENT_BINARY_DIR}/cmake/${PROJECT_NAME}Config.cmake")

  # generate the version file for the config file
  # if VERSION argument is not set it uses PROJECT_VERSION
  write_basic_package_version_file(
    "${VERSION_CONFIG}"
    COMPATIBILITY SameMajorVersion
  )

  configure_package_config_file(
    "cmake/Config.cmake.in"
    "${PROJECT_CONFIG}"
    INSTALL_DESTINATION "${CONFIG_INSTALL_DIR}"
  )

  # <install_prefix>/lib/cmake/<project_name>/
  install(
    FILES "${PROJECT_CONFIG}" "${VERSION_CONFIG}"
    DESTINATION "${CONFIG_INSTALL_DIR}"
  )

  # remove leading ;
  string(SUBSTRING "${TARGETS}" 1 -1 TARGETS)
  string(SUBSTRING "${INCLUDE_DIRS}" 1 -1 INCLUDE_DIRS)

  # <install_prefix>/lib/<target_name>
  foreach(TARGET ${TARGETS})
    install(
      TARGETS ${TARGET}
      EXPORT ${PROJECT_NAME}_Targets
      LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
      ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}"
      RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
      INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
    )
  endforeach()

  # there is no namespace as the target names are already contain make-shift namespaces
  # see https://stackoverflow.com/questions/67757157/change-exported-target-name-in-cmake-install-alias-to-a-target
  install(
    EXPORT "${PROJECT_NAME}_Targets"
    DESTINATION "${CONFIG_INSTALL_DIR}"
  )

  # <install_prefix>/include/<rel_path_to_header_file>
  foreach(ITEM ${INCLUDE_DIRS})
    install(
      DIRECTORY ${ITEM}
      DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
      FILES_MATCHING PATTERN "*.h"
    )
  endforeach()

  # export build info
  # we need to attach the project name to build macros to prevent conflicts to happen in downstream libraries
  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/include/build_info_install.h DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/include/build_info.h DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
else()
  message(FATAL_ERROR "${OPTIONS} Forcing cmake to stop.")
endif()